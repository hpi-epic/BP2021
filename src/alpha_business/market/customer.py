import math
from abc import ABC, abstractmethod

import numpy as np

import alpha_business.configuration.utils as ut


class Customer(ABC):
	@abstractmethod
	def generate_purchase_probabilities_from_offer(self, common_state, vendor_specific_state, vendor_actions) -> np.array:  # pragma: no cover
		"""
		This method receives the state of the market and uses it as a list of offers.
		It returns the purchase probability for all vendors.

		Args:
			common_state (np.array): The common state array generated by the market
			vendor_specific_state (list): The array of arrays whith an entry for each vendor
			vendor_actions (list): The array containing the action for each vendor

		Returns:
			np.array: probability distribution for all possible purchase decisions.
			In the first field, there is the probability that the customer does not buy anything.
			In the subsequent fields, there are the probabilites for buying the specific offers from the vendor.
			Look subclass implementation for more details.
		"""
		raise NotImplementedError('This method is abstract. Use a subclass')


class CustomerLinear(Customer):
	def generate_purchase_probabilities_from_offer(self, common_state, vendor_specific_state, vendor_actions) -> np.array:
		"""
		This method calculates the purchase probability for each vendor in a linear setup.
		Quality values are used to calculate a ratio.
		Customers will follow that ratio.

		Check the docstring in the superclass for interface description.
		"""
		assert isinstance(common_state, np.ndarray), 'common_state must be a np.ndarray'
		assert len(common_state) == 0, 'common_state must be an empty array in our linear setup'
		assert isinstance(vendor_specific_state, list), 'vendor_specific_state must be a list'
		assert isinstance(vendor_actions, list), 'vendor_actions must be a list'
		assert len(vendor_specific_state) == len(vendor_actions), \
			'Both the vendor_specific_state and vendor_actions contain one element per vendor. So they must have the same length.'
		assert len(vendor_specific_state) > 0, 'there must be at least one vendor.'

		nothingpreference = 1
		ratios = [nothingpreference]
		for vendor_idx in range(len(vendor_actions)):
			quality = vendor_specific_state[vendor_idx][0]
			price = vendor_actions[vendor_idx] + 1
			ratio = quality / price
			ratios.append(ratio)
		return ut.softmax(np.array(ratios))


class CustomerCircular(Customer):
	def generate_purchase_probabilities_from_offer(self, common_state, vendor_specific_state, vendor_actions) -> np.array:
		"""
		This method calculates the purchase probability for each vendor in a linear setup.
		It is assumed that all vendors do have the same quality and same reputation.
		The customer values a second-hand-product 55% compared to a new one.

		Check the docstring in the superclass for interface description.
		"""
		assert isinstance(common_state, np.ndarray), 'common_state must be a np.ndarray'
		assert isinstance(vendor_specific_state, list), 'vendor_specific_state must be a list'
		assert isinstance(vendor_actions, list), 'vendor_actions must be a list'
		assert len(vendor_specific_state) == len(vendor_actions), \
			'Both the vendor_specific_state and vendor_actions contain one element per vendor. So they must have the same length.'
		assert len(vendor_specific_state) > 0, 'there must be at least one vendor.'

		nothingpreference = 1
		preferences = [nothingpreference]
		for vendor_idx in range(len(vendor_actions)):
			price_refurbished = vendor_actions[vendor_idx][0] + 1
			price_new = vendor_actions[vendor_idx][1] + 1
			assert price_refurbished >= 1 and price_new >= 1, 'price_refurbished and price_new need to be >= 1'

			ratio_old = 5.5 / price_refurbished - math.exp(price_refurbished - 5)
			ratio_new = 10 / price_new - math.exp(price_new - 8)
			preferences += [ratio_old, ratio_new]

		return ut.softmax(np.array(preferences))
